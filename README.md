# PAD_LABS
This laboratory work comprises a microservice based system for storing ingredients and generating recipes. 

## System Architecture (updated)

![Local Image](images/SysArchitecture.drawio.png)

## Service Boundaries:
This system is designed to be simple and efficient, focusing on the core functionality of suggesting
recipes based on user-provided ingredients. Each microservice has a clear and specific role, contributing
to the overall functionality of the system.
#### Ingredient Service
Manages information about ingredients and allows users to add new
ingredients.

#### Recipe Service
Manages the recipe database and supports searching for recipes based on
ingredients.

#### Load balancer: 
Entry point to the system, distributes incoming traffic across microservices. Ensures High Availability and Load 
Distribution.

#### API Gateway
Manages and routes requests to the appropriate microservices. Provides single entry point for client, enforces 
request handling.

#### Caching
Store frequently accessed data, reduce the need to fetch data from the database.

#### Logging
Records events and activites, helps track and diagnose issues, analyze system behaviour.

#### Ingredient Microservice
Responsible for managing ingredient related data. It connects to database to store and retrieve information about 
ingredients.

#### Recipe Microservice
Manages recipe-related data and interacts with its own database. Handles recipe creation, retrieval, updates.

#### Service Discovery
Provides dynamic service registration and discovery. Allows microservices to find and communicate with each other.

## Ingredient Microservice Endpoints
#### NOTE: The endpoints enumerated below are the endpoints contained in the POSTMAN collection. Further into the implementation of the second laboratory there will be modifications.

### `GET /status`

- **Description:** Get the service status.
- **Request Method:** GET
- **Request Body:** None
- **Response:**
    - *Content-Type:* `text/plain`
    - *Body:* A string indicating the status of the services the Gateway communicates with:
    - "Ingredient Microservice Status: Online"
    - "Recipe Microservice Status: Online"

### `GET /ingredients`
- **Description:** Get ingredients list
- **Request Method:** GET
- **Request Body:** None
- **Response:**
  - *Content-Type:* `application/json`
  - *Body:* An array of ingredients as JSON objects.

  
### `POST /ingredients`
- **Request Body:**
    - *Content-Type:* `application/json`
    - *Body Example:*
      ```json
      {
          "id": 1,  // Auto-generated by the server
          "ingredient": "Example Ingredient"
      }
      ```
- **Response:**
  - *Content-Type:* `text/plain`
  - *Body:* "Ingredient added successfully"

### `POST /add_ingredients`

- **Description:** Add multiple ingredients.
- **Request Method:** POST
- **Request Body:**
    - *Content-Type:* `application/json`
    - *Body Example:*
      ```json
      [
          {
              "id": 1,  // Auto-generated by the server
              "ingredient": "Ingredient 1"
          },
          {
              "id": 2,  // Auto-generated by the server
              "ingredient": "Ingredient 2"
          }
      ]
      ```
- **Response:**
  - *Content-Type:* `text/plain`
  - *Body:* "Ingredients added successfully"

### `GET /ingredient/<id>`
- **Description:** Get an ingredient by ID.
- **Request Method:** GET
- **Request Body:** None
- **Response:**
    - *Content-Type:* `application/json`
    - *Body:* The ingredient with the specified ID as a JSON object.

# Recipe Microservice Endpoints

#### NOTE: The endpoints enumerated below are the endpoints contained in the POSTMAN collection. Further into the implementation of the second laboratory there will be modifications.

### `GET /recipes`

- **Description:** Get all recipes.
- **Request Method:** GET
- **Request Body:** None
- **Response:**
  - *Content-Type:* `application/json`
  - *Body:* An array of recipes as JSON objects.

### `POST /add_recipe`

- **Description:** Add a new recipe.
- **Request Method:** POST
- **Request Body:**
  - *Content-Type:* `application/json`
  - *Body Example:*
    ```json
    {
        "id": 1,  // Auto-generated by the server
        "recipeId": "Recipe123",
        "name": "Example Recipe",
        "ingredients": ["Ingredient1", "Ingredient2"],
        "instructions": "Step 1, Step 2, ..."
    }
    ```
- **Response:**
  - *Content-Type:* `text/plain`
  - *Body:* Recipe added successfully!

### `GET /recipes/<ingredient>`

- **Description:** Get recipes by ingredient.
- **Request Method:** GET
- **Request Body:** None
- **Response:**
  - *Content-Type:* `application/json`
  - *Body:* An array of recipes containing the specified ingredient as JSON objects.

## Tech Stack
For building microservices, I used Spring Boot. To manage API requests, balance the load on my servers, and help microservices find each other, I used Python, specifically Flask. Both of my databases are PostgreSQL, which is a reliable and high-performance choice.

For keeping track of what's happening in the system and diagnosing issues, I will set up the ELK Stack for logging. 
It will help me collect and analyze logs effectively.

To make sure all my system parts can talk to each other, I use REST communication. It's a simple and efficient way for my services to exchange data.

## Deployment
### Docker Images
In order to test the application, run the compose file from the PAD_LABORATORIES directory, using the commands:
```cmd
docker compose pull
```
```cmd
docker compose up
```

### NOTE: 
At this point in the implementation, the ingredient database must be created manually. 

Go to: *pad_laboratories-db-1* image

Write the command: *psql -U postgres*

Write the command: *create database ingredients;*

I will later write the script for this database to be created automatically.


The application is listening on port 5000. The Postman collection also contains calls on port 8001, specifically the 
Service Discovery port. You can use this endpoint to check the health of the Service Discovery. 

Please NOTE that there are multiple modifications to be made to the implementation, this is only the starting point.